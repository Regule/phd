\FloatBarrier
\chapter{Implementation of neuroevolution for generation of low resource neural networks}
This chapter is heart of this work. It describes proposed soulution, its implementation as 
well as environment used for testing it. Finally this chapter also displays results of 
experiments and ends with conclusions and suggestions for future research.

%==================================================================================================
\FloatBarrier
\section{Experimentation environment}

%--------------------------------------------------------------------------------------------------
\FloatBarrier
\subsection{Simulation versus physical environment}

%--------------------------------------------------------------------------------------------------
\FloatBarrier
\subsection{Enviroment architecture}
The experiment environment is separated into distinct modules that serve specific purposes and
communicate with each other trough serial ports with use of protocol described in section
\ref{sec:com-prot}.
Thanks to that approach each of modules is separated from other and their internal implementation
details do not affect each other. As such modifications made to one part of system do not propagate
to others, this is important as due to innovative nature of RNEAT implementation a multiple 
modifications can be implemented over the course of experiments.
Detailed interactions between modules, as well as their develpment environment and hardware
location, are visualised on Figure \ref{fig:experiment_arch}.
\begin{figure}[htb] 
	\centering
	\includegraphics[width=0.6\textwidth]{figures/experiment_arch}
	\caption{The architecture of experimentation environment.}
	\label{fig:experiment_arch}
\end{figure}

\subsubsection{Modules}

\subsubsection{Communication protocol}
\label{sec:com-prot}
To be able to interact with one another each module must use same communication protocol.
For this project main role of this protocol is to send observations and reactions between 
neural network and agent sensor and effector controler.
As this protocol is also used for communication with learning algorithm an additional information,
such as reward value or end of simulation, must be sent.
For that reason protocol starts with a command byte that identifies operation.
\begin{sidewaystable}[htb] 
	\centering
	\caption{ResNeat communication protocol}
	\label{tab:resneat-protocol}
	\begin{tabularx}{\textwidth}{cccX}
		\hline
		\hline
		Code (hex)& Command& Description& Payload\\
		\hline
		01& ORQ&  Request observation& None\\
		02& OSN& Observation sent& Unsigned integer indicating numer of features per obserbation 
		followed by array said features*\\
		03& RRQ& Request reaction& None\\
		04& RSN& Reaction sent& Unsigned integer indicating numer of features per reaction 
		followed by array said features*\\
		05& MRQ& Request mode info& None\\
		06& MSN& Mode info& A single byte set to 1 if in restricted mode or 0 if in classic\\
		07& DRQ& Request observation description& None\\
		08& DSN& Observation description& Unsigned integer indicating numer of features per observation 
		followed by two arrays containing minimum and maximum values of  said features*\\
		09& ERQ& Request reaction description& None\\
		0A& ESN& Reaction description& Unsigned integer indicating numer of features per reaction 
		followed by two arrays containing minimum and maximum values of  said features*\\
		0B& SRQ& Request simulation metadata& None\\
		0C& SSN& Simulation metadata& An 64-bit integer representing cycle number, a 64-bit float 
		representing reward and a single byte set to 1 if simulation is running or 0 if stopped\\
		0D& RST& Request reset& None\\
		0E& INI& Initiallize connection& None\\
		0F& AOK& All ok& None\\
		10& ERR& Error& None\\

		\hline
		\hline
	\end{tabularx}
	\newline
	{\footnotesize *This can be either 64-bit integer and array of doubles or 32-bit integer
	and array of 32-bit integers depending if protocol operates in classic or restricted mode}
\end{sidewaystable}

Due to differences between observation and reaction representation in in standard implementation
of NEAT and in RNEAT communincation protocol works in two modes:
\begin{enumerate}
	\item Classic - In this mode both observation and reaction are represented as a vector
		of double precision floating point numbers.
	\item Restricted - In this mode both observation and reaction are represented as a 
		24 bit fixed point number, more information about this representation is given in
		section \ref{sec:fixed-model}
\end{enumerate}
It is role of \textit{rss\_signal\_converter} to transform data between two modes. What is 
important is that only observation and reaction representation must be converted, simulation
metadata remain unchanged.
%--------------------------------------------------------------------------------------------------
\FloatBarrier
\subsection{Simulation environment - OpenAI Gym}
When preparing a simulation environment a decision must be made,wheter to creat a dedicated one
for the project or use a already available one.
As in this case purpose of experiments is to compare results of NEAT and RNEAT in variety of 
robotics related tasks a already prepared environment is a better solution.
Following simulation environments were taken into a consideration:
\begin{enumerate}
	\item Webots
	\item Gazebo
	\item Stage
	\item Gym
\end{enumerate}
Initially more attention was given to a strictly robotics dedicated environments such as 
Webots or Stage. Those were main contenders due to their use in resarch and didactics at PJATK.
However finally a decision was made to use much more general Gym as it was able to replicate
most issues faced in robotisc, such as control of mobile systems and image processing, and it
was more fit for use alongside already existing implementations of NEAT.

OpenAI Gym was created with reinforcement learning in mind, where the agentâ€™s experience is broken
down into a series of episodes. 
In each episode, agent recieves an observation and responds with an reaction and that 
interaction cotinues until the environment reaches a terminal state. 
The goal in episodic reinforcement learning is to maximize the expectation of total reward per 
episode, this is easily translatable into a fittnes function of a genetic algorithm by cumulative
sum of rewards.

\begin{lstlisting}[frame=single, language=Python, caption={A simple simulation in Gym}]
import gym
env = gym.make('CartPole-v1')
observation = env.reset()
finished = False
total_reward = 0.0
env.render()
while not finished:
  env.render()
  reaction = env.action_space.sample() # random reaction
  observation, reward, done, _ = env.step(reaction)
  total_reward += reward
  env.render()
env.close()
\end{lstlisting}

\FloatBarrier
\subsubsection{Exclusive alternative}
This is most basic environment that contain four observation, expected reaction pairs that 
correspond to XOR function as shown in table \ref{tab:xor-env}.
\begin{table}[htb] 
	\centering
	\caption{Observation, expected reaction pairs for XOR environment}
	\label{tab:xor-env}
	\begin{tabular}{ccc}
		\hline
		\hline
		 \multicolumn{2}{c}{Observation}& Reaction\\
		\hline
		$x_{2}$& $x_{1}$& $y_{1}$ \\
		\hline
		0& 0& 0\\
		0& 1& 1\\
		1& 0& 1\\
		1& 1& 1\\
		\hline
		\hline
	\end{tabular}
	\newline
\end{table}
Exclusive or is simpliest example of function that cannot be solved by a single layer perceptron
and in this case will be used as a form of verification if network implementation was written
correctly.
As solving XOR can be done with only three neurons and weights set to either 1, 0 or -1 it 
should be trivial for even a such limited model as one used in this project to solve it.
Because of that inability to solve this problem will indicate errors in implementation as it is
known that theoretical model should be able to do it.

\FloatBarrier
\subsubsection{Cart pole}
A pole is attached by a non actuated joint to a cart, which moves along a frictionless track.
The system is controlled by applying a force of +1 or -1 to the cart.
The pendulum starts upright, and the goal is to prevent it from falling over. 
\begin{figure}[htb] 
	\centering
	\includegraphics[width=0.6\textwidth]{figures/cartpole}
	\caption{A visualisation of cart pole environment.}
	\label{fig:cartpole}
\end{figure}
A reward of +1 is provided for every cycle that the pole remains upright.
The episode ends when the pole is more than 15 degrees from vertical, or the cart moves more 
than 2.4 units from the center.

\FloatBarrier
\subsubsection{Bipedal walker}
Reward is given for moving forward, total 300 points up to the far end. 
If the robot falls, it gets -100. Applying motor torque costs a small amount of points, 
more optimal agent will get better score.
State consists of hull angle speed, angular velocity, horizontal speed, vertical speed,
position of joints and joints angular speed, legs contact with ground, and 10 lidar 
rangefinder measurements
\begin{figure}[htb] 
	\centering
	\includegraphics[width=0.6\textwidth]{figures/walker}
	\caption{A visualisation of walker environment in hardcore mode.}
	\label{fig:walker}
\end{figure}
Hardcore version adds ladders, stumps, pitfalls. Time limit is increased due to obstacles. 

\FloatBarrier
\subsubsection{Lunar lander}
Landing pad is always at coordinates (0,0). Coordinates are the first two numbers in state vector.
Reward for moving from the top of the screen to landing pad and zero speed 
is about 100..140 points.
If lander moves away from landing pad it loses reward back. Episode finishes if the lander 
crashes or comes to rest, receiving additional -100 or +100 points.
Each leg ground contact is +10. Firing main engine is -0.3 points each frame.
\begin{figure}[htb] 
	\centering
	\includegraphics[width=0.6\textwidth]{figures/lunar}
	\caption{A visualisation of lunar lander environment.}
	\label{fig:lunar}
\end{figure}
Solved is 200 points. Landing outside landing pad is possible.
Fuel is infinite, so an agent can learn to fly and then land on its first attempt. 
Action is two real values vector from -1 to +1. First controls main engine, -1..0 off, 0..+1
throttle from 50\% to 100\% power. Engine can't work with less than 50\% power. 
Second value -1.0..-0.5 fire left engine, +0.5..+1.0 fire right engine, -0.5..0.5 off.

\FloatBarrier
\subsubsection{Robotank}
In this environment, the observation is an RGB image of the screen, which is an array of shape 
(210, 160, 3).

In Robotank, player is in control of a tank located in the middle of a barren field and must 
destroy enemy tanks after pinpointing their positions by using the window view and a small 
radar scope.

As shown on Figure \ref{fig:robotank}, game display is divided into two sections. 
The majority of the screen is occupied by the view of the battlefield, only objects in 
the front of vechicle are visible. 
The remainder of the screen consists of the status panel.

Located in the center of the status panel is a circular radar display with a sweeping arm.
If there is an enemy tank on the battlefield, it will appear on this display as a pink dot 
relative to robot position.
\begin{figure}[htb] 
	\centering
	\includegraphics[width=\textwidth]{figures/robotank}
	\caption{A visualisation of robotank game frame that also serves as an input for network.}
	\label{fig:robotank}
\end{figure}

Situated around the radar display are four yellow boxes with capital letters in them.
These are the damage indicators. When your tank is shot, you suffer either a direct hit or a 
glancing shot. The first destroys your tank, the latter merely damages it.
The type of damage inflicted upon your tank is random.
If the V box is on, your video display will flash on and off. C means that your cannon 
firing power is cut in half. R indicates that your radar has been rendered useless.
T simply slows down the turning ability of your Robotank
\begin{figure}[htb] 
	\centering
	\includegraphics[width=\textwidth]{figures/robotank-cam}
	\caption{A greyscale variant of a camera part of the robotank input.}
	\label{fig:robotank-cam}
\end{figure}
\begin{figure}[htb] 
	\centering
	\includegraphics[width=0.3\textwidth]{figures/robotank-radar}
	\caption{A greyscale variant of a radar part of the robotank input.}
	\label{fig:robotank-radar}
\end{figure}

%--------------------------------------------------------------------------------------------------
\FloatBarrier
\subsection{Computation device}
The chipKIT uC32 is based on the popular Arduino open-source hardware prototyping platform and
adds the performance of the  PIC32 microcontroller. 
The uC32 is the same form factor as the Arduino Uno board and is compatible with Arduino shields.
It features a USB serial port interface for connection to the IDE and can be powered via USB or an 
external power supply. 
The uC32 board takes advantage of the powerful PIC32MX340F512 microcontroller, which features a 
32-bit MIPS processor core running at 80 MHz, 512K of flash program memory, and 32K of
SRAM data memory.
\begin{figure}[htb] 
	\centering
	\includegraphics[width=\textwidth]{figures/pic_board}
	\caption{A uC32 board used in this experiments.}
	\label{fig:pic-board}
\end{figure}
This board have following properties:
\begin{itemize}
	\item Microchip PIC32MX340F512H
		\begin{itemize}
			\item 80 MHz
			\item 32-bit MIPS
			\item 512K Flash
			\item 32K SRAM
		\end{itemize}
	\item Compatible with many existing Arduino code samples and other resources
	\item Compatible with many Arduino shields
	\item 43 available I/O pins
	\item PC connection uses a USB A > mini B cable
\end{itemize}

%==================================================================================================
\FloatBarrier
\section{Topological neural network implementation in low resource environment}

%--------------------------------------------------------------------------------------------------
\FloatBarrier
\subsection{Native implementation on 64-bit architecture}
Native representation of topologically varying neural network must rely on graph structure as 
simple matrix per layer representation assumes fully connected layered structure.
\begin{figure}[htb] 
	\centering
	\includegraphics[width=0.3\textwidth]{figures/xor_network}
	\caption{An example of network graph for solving XOR problem.}
	\label{fig:xor_network}
\end{figure}
As shown on figure \ref{fig:xor_network} ANN consists of typical graph elements, 
nodes and links. Some of the nodes are recognised as an inputs or outputs where others are 
considered hidden nodes. While not visible on this visualisation nodes also need to store 
additional information, because of that a connection graph is also not a valid solution
as it only contains information about connection weights as shown on equation 
\ref{equ:connection_grid}.
\begin{equation}
	\label{equ:connection_grid}
	NET = \begin{bmatrix}
		0 & 0 & 2 & 2 & -1\\
		0 & 0 & 0 & 0 & 3\\
		0 & 0 & 0 & 0 & -3\\
	\end{bmatrix}
\end{equation}
Another significant disadventage is high memory requirements for use of that representation as 
each node requires its own row as well as column. This makes memory complexity of connection 
matrix $n^2$ where $n$ is number of nodes.
This negates one of main advantages of neuroevolution, it ability to create sparsly connected 
networks.
After rejecting that approach next logical step is selection of memory pointer functionality
that is natively implemented in most of lower level programming languages.
In shuch representation both nodes and links are stored in specialised structures in program
memory. Relations between those elements are modeled as a pointers to memory parts where target
objects are stored.
In case of solution described in this paper all implementation was done in C programming language
as it a solution with least overhead and a well established language in microcontroller
programming. 
Implementation details are crutial to thesis formed in this work an as such code listings will be
provided in a specific language instead of pseudocode.
\begin{lstlisting}[frame=single, language=C, caption={Implementation of Node and Link structures in C}]
typedef struct Node_t{
	int cycle;
	double value;
	double (*activation)(double);
	double (*agregation)(const Vector*);
	size_t connection_count;
	Connection** connections;
} Node;

typedef struct Connection_t{
	double weight;
	Node* target;
}Connection;
\end{lstlisting}
Additionally to be able to determine how much resources does implementation use a knowledge of 
hardware architecure of used device is requred.
Most of moder computers use 64-bit architecture witch hardware implementation of floating point
operations. That means that single integer takes 64 bits of memory space and there is no 
computation overhead when using floating point variables instead of fixed point ones.

%--------------------------------------------------------------------------------------------------
\FloatBarrier
\subsection{Limitations in robotic applications}

%--------------------------------------------------------------------------------------------------
\FloatBarrier
\subsection{Computation efficiency - 24-bit fixed point model}
\label{sec:fixed-model}
In order to implement 

%--------------------------------------------------------------------------------------------------
\FloatBarrier
\subsection{Memory efficiency - offset based model}
