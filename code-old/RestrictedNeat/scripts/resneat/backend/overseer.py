'''
This module contains an Overseer class that is central element of experiment.
'''

import gym
import neat
from resneat.backend.signal_processing import SignalPreprocessingUnit

def verify_neural_library(neural_library):
    '''
    This class checks if selected neural_library provides required level of compatibility 
    with PyNeat.

        @param neural_library Module that handles neural network and neuroevolution functionality.
        @return Tuple that contains (True,None) if module provides compatibility or tuple that
                contains (False, List) if it does not. Returned list contains elements that are 
                not found in module.
    '''
    # TODO: Add actual body to this function if needed.
    return (True, None)



class Overseer:
    '''
    This is experiment main class, it role is to prepare all environments and oversee 
    execution of neuroevolutuion. What is important is that this class is agnostic toward 
    implementation of neural network.
    '''

    def __init__(self, environment, signal_preprocessing_unit, neural_library,
            maximum_cycles):
        '''
        Initializer for Overseer class. It can either recieve a custom Gym environment or 
        name of one of default ones. In second case it will attempt to load given environment
        from Gym.

            @param environment Name of default Gym environment or a object that is custom one.
            @param signal_preprocessing_unit Object that relay signals between Gym environment 
                                             and neural network.
            @param neural_library Module responsible for handling networks and neuroevolution
            @param maximum_cycles Maximum number of simulation cycles
            @return Returns nothing
        '''
        if  isinstance(environment, str):
            self.environment = gym.make(environment)
        elif isinstance(environment, gym.Env):
            self.environment = environment
        else:
            raise TypeError(f'Overseer expects environment as either string or gym.Env object, instead recieved {type(environment)}.')
        
        if not isinstance(signal_preprocessing_unit, SignalPreprocessingUnit):
            raise TypeError(f'Signal preprocessing unit must inherit SignalPreprocessingUnit class while {type(environment)} do not.')
        self.signal_preprocessing_unit = signal_preprocessing_unit
        
        library_ok, problem_list = verify_neural_library(neural_library)
        if not library_ok:
            raise ImportError(f'Module {neural_library} lacks following compatibilities with PyNeat {problem_list}')
        self.neural_library = neural_library

        self.maximum_cycles = maximum_cycles
        self.best_specimen = None
        self.population = None

    
    def run_neuroevolution(self, config_file, maximum_generations, reporters=[]):
        '''
        This is equivalent of main function for running neuroevolution, it must recieve
        a configuration file that is compatibile with either PyNeat or Restricted Neat.
        If a incorrect configuration file is given then an exception will be thrown.
        Additionaly it is possible to give a list of reporter objects that will be added
        to neuroevolution process, those must be configured outside of this function.

            @param config_file Path to configuration file
            @param maximum_generations Maximum number of generations that will be ran, it can be less if early stop parameters are defined.
            @param reproters List of reporter objects
            @return Best specimen after complete evolution process, this object is also
                    accesible as a field "best_specimen" in Overseer object.
        '''
        config = self.neural_library.Config(
                                        self.neural_library.DefaultGenome,
                                        self.neural_library.DefaultReproduction,
                                        self.neural_library.DefaultSpeciesSet,
                                        self.neural_library.DefaultStagnation,
                                        config_file)
        self.population = self.neural_library.Population(config)
        for reporter in reporters:
            self.population.add_reporter(reporter)
        self.best_specimen = self.population.run(self, maximum_generations)

    def __call__(self, population, configuration):
        '''
        Overriding call operator allows use of this class as a functor and passing it to
        neuroevolution loop. Thanks to that functor have acces to all configuration and
        environment data stored in overseer. Parameters of this function are defined in
        order to maintain compatibility with PyNeat.

            @param population Population object generated by neuroevolution library
            @param configuration A configuration object
        '''
        for genome_id, genome in population:
            net = neat.nn.FeedForwardNetwork.create(genome, configuration)
            genome.fitness = 0.0
            observation = self.environment.reset()
            finished = False
            for _ in range(self.maximum_cycles):
                reaction = net.activate(observation) 
                observation, reward, finished, _ = self.environment.step(reaction)
                genome.fitness += reward
                if finished:
#                    genome.fitness -= config.break_punishment 
                    break

