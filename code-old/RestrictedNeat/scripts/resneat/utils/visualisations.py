'''
This module contains functions helpfull with visualisation of results generated by 
neuroevolution. Many of them will be included in reporters however it is also possible to use 
them directly.
'''

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt


def plot_statistics(statistics, name, display_window=False,
        file_name=None, csv_file_name=None):
    '''
    This function generates a plot that shows best, avarage and worst fitness in 
    population over all generations.

        @param statistics A statistics reporter object from PyNeat
        @param name Name identifing a specific neuroevolution experiment
        @param display_window If set to true a window with plot will be displayed to user
        @param file_name If not none a plot will be saved into given file
        @param csv_file_name If not none data used for generating plot will be also to written to
                             csv file for future use.
    '''

    generations = range(len(statistics.most_fit_genomes))
    best = [c.fitness for c in statistics.most_fit_genomes]
    avarage = np.array(statistics.get_fitness_mean())

    plt.plot(generations, avarage, '--', label='average')
    plt.plot(generations, best, '-', label='best')

    plt.title('Population fitness')
    plt.xlabel('Generations')
    plt.ylabel('Fitness')
    plt.grid()
    plt.legend()

    if file_name is not None:
        plt.savefig(file_name)
    if display_window is not None:
        plt.show()
    if csv_file_name is not None:
        data_frame = pd.DataFrame({'best': best, 'avarage':avarage})
        data_frame.to_csv(csv_file_name)

    plt.close()


def plot_speciation(statistics, name, display_window=False, file_name=None, 
        csv_file=None):
    '''
    This function generates plot that shows spieces participation in population over
    generations.

        @param statistics A statistics reporter object from PyNeat
        @param name Name identifing a specific neuroevolution experiment
        @param display_window If set to true a window with plot will be displayed to user
        @param file_name If not none a plot will be saved into given file
        @param csv_file_name If not none data used for generating plot will be also to written to
                             csv file for future use.
    '''

    species_sizes = statistics.get_species_sizes()
    generations = len(species_sizes)
    curves = np.array(species_sizes).T

    fig, ax = plt.subplots()
    ax.stackplot(range(generations), *curves)

    plt.title('Speciation')
    plt.ylabel('Size per Species')
    plt.xlabel('Generations')

    if file_name is not None:
        plt.savefig(file_name)
    if display_window is not None:
        plt.show()
    # FIXME: ADD THIS FUNCTIONALITY
#    if csv_file_name is not None:
#        data_frame = pd.DataFrame({'best': best, 'avarage':avarage})

    plt.close()


def draw_network_graph(config, genome, view=False, filename=None, node_names=None,
        show_disabled=True, prune_unused=False, node_colors=None, fmt='svg'):
    """ Receives a genome and draws a neural network with arbitrary topology. """
    # Attributes for network nodes.
    if graphviz is None:
        warnings.warn("This display is not available due to a missing optional dependency (graphviz)")
        return

    if node_names is None:
        node_names = {}

    assert type(node_names) is dict

    if node_colors is None:
        node_colors = {}

    assert type(node_colors) is dict

    node_attrs = {
        'shape': 'circle',
        'fontsize': '9',
        'height': '0.2',
        'width': '0.2'}

    dot = graphviz.Digraph(format=fmt, node_attr=node_attrs)

    inputs = set()
    for k in config.genome_config.input_keys:
        inputs.add(k)
        name = node_names.get(k, str(k))
        input_attrs = {'style': 'filled', 'shape': 'box', 'fillcolor': node_colors.get(k, 'lightgray')}
        dot.node(name, _attributes=input_attrs)

    outputs = set()
    for k in config.genome_config.output_keys:
        outputs.add(k)
        name = node_names.get(k, str(k))
        node_attrs = {'style': 'filled', 'fillcolor': node_colors.get(k, 'lightblue')}

        dot.node(name, _attributes=node_attrs)

    if prune_unused:
        connections = set()
        for cg in genome.connections.values():
            if cg.enabled or show_disabled:
                connections.add((cg.in_node_id, cg.out_node_id))

        used_nodes = copy.copy(outputs)
        pending = copy.copy(outputs)
        while pending:
            new_pending = set()
            for a, b in connections:
                if b in pending and a not in used_nodes:
                    new_pending.add(a)
                    used_nodes.add(a)
            pending = new_pending
    else:
        used_nodes = set(genome.nodes.keys())

    for n in used_nodes:
        if n in inputs or n in outputs:
            continue

        attrs = {'style': 'filled',
                 'fillcolor': node_colors.get(n, 'white')}
        dot.node(str(n), _attributes=attrs)

    for cg in genome.connections.values():
        if cg.enabled or show_disabled:
            #if cg.input not in used_nodes or cg.output not in used_nodes:
            #    continue
            input, output = cg.key
            a = node_names.get(input, str(input))
            b = node_names.get(output, str(output))
            style = 'solid' if cg.enabled else 'dotted'
            color = 'green' if cg.weight > 0 else 'red'
            width = str(0.1 + abs(cg.weight / 5.0))
            dot.edge(a, b, _attributes={'style': style, 'color': color, 'penwidth': width})

    dot.render(filename, view=view)

    return dot
